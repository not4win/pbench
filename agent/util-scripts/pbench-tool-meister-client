#!/usr/bin/env python3
# -*- mode: python -*-

"""pbench-tool-meister-client

Responsible for publishing the requested tool meister operation.  The
operation can be one of "start", "stop", "send", "postprocess" or "kill".
"""

import sys
import os
import json
import errno
import logging
import redis


# FIXME: move to common area
redis_host = 'localhost'
# Port number is "One Tool" in hex 0x17001
redis_port = 17001

# FIXME: this should be moved to a shared area
channel = "tool-meister-chan"

# List of valid operations
operations = ( 'start', 'stop', 'send', 'postprocess', 'kill' )


def main(argv):
    """Main program for the tool meister client.
    """
    PROG = os.path.basename(argv[0])
    logger = logging.getLogger(PROG)

    logger.setLevel(logging.INFO)
    sh = logging.StreamHandler()
    sh.setLevel(logging.INFO)
    shf = logging.Formatter('%(message)s')
    sh.setFormatter(shf)
    logger.addHandler(sh)

    try:
        group = argv[1]
    except IndexError:
        raise Exception("Missing group argument")
    try:
        iteration = argv[2]
    except IndexError:
        raise Exception("Missing iteration argument")
    try:
        sample = argv[3]
    except IndexError:
        raise Exception("Missing sample argument")
    try:
        operation = argv[4]
    except IndexError:
        raise Exception("Missing operation argument")
    else:
        if operation not in operations:
            raise Exception(
                    "Unrecognized operation, '{operation}', valid operations"
                    " are: '{operations}'")
        elif operation == 'postprocess':
            # We map the legacy "postprocess" action to the new "send" action.
            operation = 'send'
        elif operation == 'kill':
            # FIXME: we need to implement the gritty method of killing all the
            # tool meisters, locally and remotely, and ensuring they are all
            # properly shut down.
            return 0

    try:
        redis_server = redis.Redis(host=redis_host, port=redis_port, db=0)
    except Exception as e:
        logger.error("Unable to connect to redis server, %s:%s: %s",
                redis_host, redis_port, e)
        return 2

    msg = dict(state=operation, iteration=iteration, sample=sample,
            group=group)
    try:
        ret = redis_server.publish(channel, json.dumps(msg))
    except redis.RedisError:
        logger.exception("Failed to publish client message")
    else:
        logger.debug("publish() = %r", ret)

    return 0


if __name__ == '__main__':
    status = main(sys.argv)
    sys.exit(status)
